package main

import (
	"os"
	"fmt"
	"mapreduce"
	"sort"
	"strings"
	"unicode"
	"strconv"
)

// The mapping function is called once for each piece of the input.
// In this framework, the key is the name of the file that is being processed,
// and the value is the file's contents. The return value should be a slice of
// key/value pairs, each represented by a mapreduce.KeyValue.
func mapF(document string, value string) (res []mapreduce.KeyValue) {
	// Your code here (Part II).
	words := strings.FieldsFunc(value, func(c rune) bool {
		return !unicode.IsLetter(c)
	})
	var retKVs []mapreduce.KeyValue
	for _, w := range words {
		retKVs = append(retKVs, mapreduce.KeyValue{w, document})
	}
	return retKVs
}

// The reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
type MyKV struct {
	K string
	V int
}

func reduceF(key string, values []string) string {
	// Your code here (Part V).
	//m := make(map[string]int)

	//for _, doc := range values {
	//	m[doc]++
	//}

	//// Convert map to KVs
	//var keys []string
	//for k := range m {
	//	keys = append(keys, k)
	//}
	//var kvs []MyKV
	//for _, k := range keys {
	//	kvs = append(kvs, MyKV{k, m[k]})
	//}


	//// Sort KVs by value and then extract keys
	//sort.Slice(kvs, func(i, j int) bool {
	//	return (kvs[i].V > kvs[j].V) || (kvs[i].V == kvs[j].V && kvs[i].K < kvs[j].K)
	//})
	//var sortedDocs []string
	//for _, kv := range kvs {
	//	sortedDocs = append(sortedDocs, kv.K)
	//}

	//if key == "years" {
	//	fmt.Println(kvs)
	//	fmt.Println(sortedDocs)
	//}

	//// Format result
	//merged := strconv.Itoa(len(keys)) + " " + strings.Join(sortedDocs, ",")

	//return merged

	// Naive sol works ;)
	var docs []string
	s := make(map[string]bool)
	for _, doc := range values {
		if !s[doc] {
			docs = append(docs, doc)
			s[doc] = true
		}
	}
	sort.Strings(docs)
	merged := strconv.Itoa(len(docs)) + " " + strings.Join(docs, ",")
	return merged
}

// Can be run in 3 ways:
// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)
// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)
// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &)
func main() {
	if len(os.Args) < 4 {
		fmt.Printf("%s: see usage comments in file\n", os.Args[0])
	} else if os.Args[1] == "master" {
		var mr *mapreduce.Master
		if os.Args[2] == "sequential" {
			mr = mapreduce.Sequential("iiseq", os.Args[3:], 3, mapF, reduceF)
		} else {
			mr = mapreduce.Distributed("iiseq", os.Args[3:], 3, os.Args[2])
		}
		mr.Wait()
	} else {
		mapreduce.RunWorker(os.Args[2], os.Args[3], mapF, reduceF, 100, nil)
	}
}
